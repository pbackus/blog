<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Paul's Dev Blog - Programming</title><link href="https://pbackus.github.io/blog/" rel="alternate"></link><link href="https://pbackus.github.io/blog/feeds/programming.atom.xml" rel="self"></link><id>https://pbackus.github.io/blog/</id><updated>2020-08-23T00:00:00-04:00</updated><entry><title>What Does Memory Safety Really Mean in D?</title><link href="https://pbackus.github.io/blog/what-does-memory-safety-really-mean-in-d.html" rel="alternate"></link><published>2020-08-23T00:00:00-04:00</published><updated>2020-08-23T00:00:00-04:00</updated><author><name>Paul Backus</name></author><id>tag:pbackus.github.io,2020-08-23:/blog/what-does-memory-safety-really-mean-in-d.html</id><summary type="html">&lt;p&gt;Recently, in the D community, there's been a good deal of discussion about what
exactly is meant by "memory safety," and under what circumstances (if any) it's
appropriate to consider an &lt;code&gt;extern(C)&lt;/code&gt; function to be "memory safe." This post
is my attempt to clarify my own thoughts on the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently, in the D community, there's been a good deal of discussion about what
exactly is meant by "memory safety," and under what circumstances (if any) it's
appropriate to consider an &lt;code&gt;extern(C)&lt;/code&gt; function to be "memory safe." This post
is my attempt to clarify my own thoughts on the subject by putting them in
writing.&lt;/p&gt;
&lt;p&gt;None of these ideas are original to me, and many are not even original to D.
Any mistakes you might notice, however, are almost certainly my own. :)&lt;/p&gt;
&lt;h3&gt;What is Memory Safety?&lt;/h3&gt;
&lt;p&gt;The D language's &lt;a href="https://dlang.org/spec/memory-safe-d.html"&gt;specification of memory safety&lt;/a&gt; defines "memory
safety" as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Memory Safety for a program is defined as it being impossible for the program
to corrupt memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This definition is frustratingly vague. What does it mean, exactly, for a
program to "corrupt memory"? Does an out-of-bounds array access "corrupt
memory"? Does it matter if the access is a read or a write? And what about
"impossible"—does it count if a D program causes memory corruption when running
on faulty hardware? If not, where do we draw the line? The D language
specification gives no answers to these questions.&lt;/p&gt;
&lt;p&gt;A concept closely related to "memory safety" is "undefined behavior." The &lt;a href="http://port70.net/~nsz/c/c99/n1256.html"&gt;C99
standard&lt;/a&gt; defines "undefined behavior" as &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;behavior, upon use of a nonportable or erroneous program construct or of
 erroneous data, for which this International Standard imposes no
 requirements &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Many systems languages, including D, adopt this definition.&lt;/p&gt;
&lt;p&gt;It's clear that whatever it may mean to "corrupt memory," a program whose
behavior is undefined is free to do so; after all, it's free to do anything.
So, at minimum, a program that is memory safe must have no undefined behavior.&lt;/p&gt;
&lt;p&gt;Whether there is any &lt;em&gt;defined&lt;/em&gt; behavior that is also considered "memory
corruption" is a question I'll return to later.&lt;/p&gt;
&lt;h3&gt;Is @safe Code Memory-Safe?&lt;/h3&gt;
&lt;p&gt;In D, functions marked with &lt;code&gt;@safe&lt;/code&gt; are checked automatically for memory
safety. Assuming these checks are implemented correctly, a program consisting
only of &lt;code&gt;@safe&lt;/code&gt; D code is guaranteed to be memory-safe.&lt;/p&gt;
&lt;p&gt;Unfortunately, it's impossible to write a program that does anything useful
using only &lt;code&gt;@safe&lt;/code&gt; code, because &lt;code&gt;@safe&lt;/code&gt; code can't do I/O or make system
calls. In order to bridge this gap between the world of &lt;code&gt;@safe&lt;/code&gt; and the world
outside, D has &lt;code&gt;@trusted&lt;/code&gt; functions, which are allowed to perform operations
that violate &lt;code&gt;@safe&lt;/code&gt;'s checks (including calling unchecked &lt;code&gt;@system&lt;/code&gt;
functions), but can still be called from &lt;code&gt;@safe&lt;/code&gt; functions.&lt;/p&gt;
&lt;p&gt;When checking &lt;code&gt;@safe&lt;/code&gt; code, the D compiler &lt;em&gt;assumes&lt;/em&gt; that all &lt;code&gt;@trusted&lt;/code&gt;
functions are memory-safe. Therefore, in any useful program, your &lt;code&gt;@safe&lt;/code&gt; code
is &lt;em&gt;truly&lt;/em&gt; memory-safe only if your &lt;code&gt;@trusted&lt;/code&gt; code is also memory-safe.&lt;/p&gt;
&lt;p&gt;Establishing that your &lt;code&gt;@trusted&lt;/code&gt; code is memory-safe is left as an excercise
to the programmer.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;@safe&lt;/code&gt; doesn't actually guarantee memory safety, why is it useful at all?
Because it reduces the incredibly difficult problem of proving that your entire
program is memory-safe to the relatively tractable one of proving that your
&lt;code&gt;@trusted&lt;/code&gt; code is memory-safe.&lt;/p&gt;
&lt;h3&gt;Can External Functions be @trusted?&lt;/h3&gt;
&lt;p&gt;What about external library functions, whose source code may not be available?
Is there any way to prove that such a function is memory-safe?&lt;/p&gt;
&lt;p&gt;The strict, hard-line answer is...no. It's impossible. When you write an
&lt;code&gt;extern&lt;/code&gt; function declaration, the only guarantee you have is that the function
you call matches the specified signature. The actual implementation of that
function isn't know until your program is compiled and linked--or in the case
of dynamic linking, until it's executed!&lt;/p&gt;
&lt;p&gt;Does that mean &lt;code&gt;@trusted&lt;/code&gt; is useless? Not quite. To see why, let's look at an
an example.&lt;/p&gt;
&lt;p&gt;Suppose we're trying to write a memory-safe &lt;code&gt;@trusted&lt;/code&gt; wrapper around the C
library function &lt;code&gt;puts&lt;/code&gt;. From reading the C99 standard, we know that &lt;code&gt;puts&lt;/code&gt;
has defined behavior when called with a pointer to a null-terminated string,
and undefined behavior otherwise, so we write our function as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nd"&gt;@trusted&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;safePuts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;)[]&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[$&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;s must be null-terminated&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;puts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we ask: what would have to go wrong for this function to corrupt memory?&lt;/p&gt;
&lt;p&gt;The array access, &lt;code&gt;s[$ - 1]&lt;/code&gt;, can't corrupt memory, because array accesses in D are
bounds-checked. Similarly, we know that comparing two characters and throwing
an exception are both safe operations, because their behavior as defined by the
language spec does not include any possibility of memory corruption. The only
remaining thing that could possibly go wrong is the call to &lt;code&gt;puts&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let's assume, for now, that the only way a call to &lt;code&gt;puts&lt;/code&gt; can corrupt memory is
by causing undefined behavior. There are two possible ways this could happen:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We call &lt;code&gt;puts&lt;/code&gt; with something other than a pointer to a null-terminated
   string.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;puts&lt;/code&gt; has a bug in its implementation and can cause undefined behavior even
   when it's called with a null-terminated string.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can rule out #1 because our function checks for null-termination before
calling &lt;code&gt;puts&lt;/code&gt;, so the only possibility left is #2. Since the C99 standard
defines the behavior of &lt;code&gt;puts&lt;/code&gt; when it's called with a null-terminated string,
we can conclude that our code is memory-safe as long as &lt;code&gt;puts&lt;/code&gt; conforms to the
C99 standard.&lt;/p&gt;
&lt;p&gt;This is not a 100% ironclad guarantee, but it's a pretty good one. As long as
our C library implementation is well-tested, our &lt;code&gt;@trusted&lt;/code&gt; code should be
fine.&lt;/p&gt;
&lt;p&gt;We can apply the same approach to other external functions: assume that they
behave as described in the relevant standard, specification, or documentation,
and then prove that our &lt;code&gt;@trusted&lt;/code&gt; code is memory-safe as long as that
assumption holds.&lt;/p&gt;
&lt;h3&gt;Is All Well-Defined Behavior Memory-Safe?&lt;/h3&gt;
&lt;p&gt;The D spec doesn't answer this question directly, but &lt;a href="https://dlang.org/spec/function.html#function-safety"&gt;the section on function
safety&lt;/a&gt; gives us some clues.&lt;/p&gt;
&lt;p&gt;Recall that a D program consisting of only &lt;code&gt;@safe&lt;/code&gt; code is guaranteed to be
memory-safe, according to D's definition of memory safety. It follows from this
that any operation a purely-&lt;code&gt;@safe&lt;/code&gt; program is allowed to perform &lt;em&gt;must&lt;/em&gt; be a
memory-safe operation—again, according to the definition of "memory-safe" used
in the D spec.&lt;/p&gt;
&lt;p&gt;Here's the twist: &lt;code&gt;@safe&lt;/code&gt; D code is allowed to dereference a pointer.&lt;/p&gt;
&lt;p&gt;At first glance, this seems impossible. In most systems languages, including D,
dereferencing a pointer when you're not supposed to is considered undefined
behavior. How does D get away with allowing &lt;code&gt;@safe&lt;/code&gt; code to do this?&lt;/p&gt;
&lt;p&gt;If we scroll down a bit to &lt;a href="https://dlang.org/spec/function.html#safe-values"&gt;the section on safe values&lt;/a&gt;, we find
our answer. The D spec divides pointer values into two categories: "valid" and
"invalid". A valid pointer is one that can be dereferenced without causing
undefined behavior.&lt;/p&gt;
&lt;p&gt;In purely-&lt;code&gt;@safe&lt;/code&gt; D code, every operation that could possibly create an invalid
pointer is a compile-time error. Pointer arithmetic, casting, and type punning
are banned. Escape analysis ensures stack pointers are always valid; GC ensures
heap pointers are always valid.&lt;/p&gt;
&lt;p&gt;Interestingly, &lt;code&gt;@safe&lt;/code&gt; D code &lt;em&gt;is&lt;/em&gt; allowed to create null pointers, which
implies that in D, the behavior of dereferencing &lt;code&gt;null&lt;/code&gt; is actually
well-defined.&lt;/p&gt;
&lt;p&gt;So dereferencing a pointer in &lt;code&gt;@safe&lt;/code&gt; code is considered memory-safe because
there's no way to access an invalid pointer from &lt;code&gt;@safe&lt;/code&gt; code. It follows that
any code which allows an invalid pointer to be accessed from &lt;code&gt;@safe&lt;/code&gt; code is
guilty of violating memory safety. Even if the offending code contains no
undefined behavior.&lt;/p&gt;
&lt;p&gt;The easiest way for this to happen is for a &lt;code&gt;@trusted&lt;/code&gt; function to either (a)
create an invalid pointer and return it, or (b) invalidate an existing pointer
that's accessible from &lt;code&gt;@safe&lt;/code&gt; code.&lt;/p&gt;
&lt;p&gt;Currently, the only perfectly-reliable way to work with invalid pointers while
preventing &lt;code&gt;@safe&lt;/code&gt; code from accessing them is to store them in local variables
of &lt;code&gt;@trusted&lt;/code&gt; or &lt;code&gt;@system&lt;/code&gt; functions (or in closures that capture those
variables). For global variables and aggregate members, the only
access-protection mechanism is &lt;code&gt;private&lt;/code&gt;, which still allows access from
&lt;code&gt;@safe&lt;/code&gt; code in the same module.&lt;/p&gt;
&lt;h3&gt;What About Arrays?&lt;/h3&gt;
&lt;p&gt;Array access is considered memory-safe (and therefore &lt;code&gt;@safe&lt;/code&gt;) because it's
bounds-checked at runtime. But this bounds-checking relies on the fact that the
&lt;code&gt;.length&lt;/code&gt; property of an array matches the actual length of the array in
memory. How is that guaranteed?&lt;/p&gt;
&lt;p&gt;Just like with pointers, D forbids, in &lt;code&gt;@safe&lt;/code&gt; code, any operation that could
possibly create an invalid array. In particular, any change to the array's
length that &lt;em&gt;would&lt;/em&gt; create an invalid array triggers a reallocation, using the
GC.&lt;/p&gt;
&lt;p&gt;Because arrays are built into the language, their internals do not suffer from
the same access-protection hole as &lt;code&gt;private&lt;/code&gt; variables w.r.t. &lt;code&gt;@safe&lt;/code&gt; code in
the same module. In this way, built-in arrays are privileged over user-defined
types, which have no equivalent access-protection mechanism.&lt;/p&gt;
&lt;h3&gt;Invariants, Generally&lt;/h3&gt;
&lt;p&gt;Generalizing from the above two examples, we can derive the general principle
that any data which must uphold some run-time invariant in order to be "valid"
(i.e., memory-safe to use) must &lt;em&gt;not&lt;/em&gt; be directly accessible from &lt;code&gt;@safe&lt;/code&gt; code,
but instead encapsulated behind a &lt;code&gt;@safe&lt;/code&gt;/&lt;code&gt;@trusted&lt;/code&gt; interface that maintains
that invariant.&lt;/p&gt;
&lt;p&gt;Some examples of such potentially-invalid data include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The tag and union of a tagged union.&lt;/li&gt;
&lt;li&gt;The reference count and data pointer of a reference-counted pointer.&lt;/li&gt;
&lt;li&gt;The allocator instance of an allocator-aware container.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To protect potentially-invalid data from access from &lt;code&gt;@safe&lt;/code&gt; code, there are
several possible solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hide the data inside closures.&lt;/strong&gt; While this solution requires no language
   changes, it is unsatisfactory because it requires the use of the GC and
   substantially complicates the implementation of aggregates that wish to use
   it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Forbid &lt;code&gt;@safe&lt;/code&gt; code from accessing &lt;code&gt;private&lt;/code&gt; data, even in the same
   module.&lt;/strong&gt; While this would work, it is a breaking change, and would cause
   many "false positives," since many &lt;code&gt;private&lt;/code&gt; member variables are not
   subject to memory-safety related invariants.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Allow the data to be explicitly marked as inaccessible from &lt;code&gt;@safe&lt;/code&gt;
   code.&lt;/strong&gt; This is the solution proposed by &lt;a href="https://github.com/dlang/DIPs/blob/8a14e07198a1c9cb7b497ae8c2ec66540fba8893/DIPs/DIP1035.md"&gt;DIP 1035&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Just rely on &lt;code&gt;private&lt;/code&gt;.&lt;/strong&gt; This is not a total loss, since &lt;code&gt;private&lt;/code&gt; does
   provide &lt;em&gt;some&lt;/em&gt; protection, but it means that all &lt;code&gt;@safe&lt;/code&gt; functions in a
   module that contains potentially-invalid variables or aggregate members must
   be considered effectively &lt;code&gt;@trusted&lt;/code&gt;, and subject to manual rather than
   automatic verification of memory safety.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Summary and Conclusions&lt;/h3&gt;
&lt;p&gt;Memory safety in D means both the absence of undefined behavior, and the
absence of certain kinds of data (which I've termed "invalid") that could lead
to undefined behavior. To corrupt memory means to either (a) invoke undefined
behavior, or (b) expose invalid data to &lt;code&gt;@safe&lt;/code&gt; code (which could then use it
to invoke undefined behavior).&lt;/p&gt;
&lt;p&gt;To prove that a &lt;code&gt;@safe&lt;/code&gt; program is memory safe, &lt;em&gt;all&lt;/em&gt; of the following steps
must be completed:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Prove that the assumptions made by &lt;code&gt;@trusted&lt;/code&gt; code about external functions
   hold.&lt;/li&gt;
&lt;li&gt;Prove that, if those assumptions hold, the &lt;code&gt;@trusted&lt;/code&gt; code is memory safe.&lt;/li&gt;
&lt;li&gt;Prove that, if the &lt;code&gt;@trusted&lt;/code&gt; code is memory safe, the &lt;code&gt;@safe&lt;/code&gt; code is
   memory safe.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Step 1 is performed by the party compiling and linking the program. Step 2 is
performed by the author(s) of the &lt;code&gt;@trusted&lt;/code&gt; code. And step 3 is performed by
the compiler. If any step is skipped, or performed incorrectly, the proof does
not hold.&lt;/p&gt;
&lt;p&gt;When performing step 3, the D compiler relies on the assumption that invalid
data cannot be accessed from &lt;code&gt;@safe&lt;/code&gt; code. It upholds this assumption
automatically in purely-&lt;code&gt;@safe&lt;/code&gt; code, and relies on the programmer to uphold it
in &lt;code&gt;@trusted&lt;/code&gt; code.&lt;/p&gt;
&lt;p&gt;Unfortunately, in the current D language, it is impossible for the programmer
to uphold this assumption in &lt;code&gt;@trusted&lt;/code&gt; code in all cases without making
unacceptable feature, performance, and implementation-quality tradeoffs. DIP
1035 would solve this problem. The current approach, of relying on &lt;code&gt;private&lt;/code&gt;,
requires manual verification of &lt;code&gt;@safe&lt;/code&gt; code in order for the compiler's proof
of memory safety to remain valid.&lt;/p&gt;</content><category term="Programming"></category><category term="dlang"></category></entry><entry><title>Beating std::visit Without Really Trying</title><link href="https://pbackus.github.io/blog/beating-stdvisit-without-really-trying.html" rel="alternate"></link><published>2019-10-04T00:00:00-04:00</published><updated>2019-10-04T00:00:00-04:00</updated><author><name>Paul Backus</name></author><id>tag:pbackus.github.io,2019-10-04:/blog/beating-stdvisit-without-really-trying.html</id><summary type="html">&lt;p&gt;One of my current projects is &lt;a href="https://code.dlang.org/packages/sumtype"&gt;a sum type implementation for the D programming
language&lt;/a&gt;. It bills itself as having "zero overhead compared to hand-written
C," and while there are sound theoretical reasons to think that's true, I'd
never actually sat down and verified it empirically. Was I really getting …&lt;/p&gt;</summary><content type="html">&lt;p&gt;One of my current projects is &lt;a href="https://code.dlang.org/packages/sumtype"&gt;a sum type implementation for the D programming
language&lt;/a&gt;. It bills itself as having "zero overhead compared to hand-written
C," and while there are sound theoretical reasons to think that's true, I'd
never actually sat down and verified it empirically. Was I really getting the
optimal performance I thought I was?&lt;/p&gt;
&lt;p&gt;I was also curious to see how my efforts stacked up next to C++17's
&lt;a href="https://en.cppreference.com/w/cpp/header/variant"&gt;&lt;code&gt;&amp;lt;variant&amp;gt;&lt;/code&gt;&lt;/a&gt; and D's &lt;a href="https://dlang.org/phobos/std_variant.html#.Algebraic"&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt;, especially after reading a few &lt;a href="https://bitbashing.io/std-visit.html"&gt;blog
posts&lt;/a&gt; and &lt;a href="https://www.reddit.com/r/cpp/comments/9khij8/stdvariant_code_bloat_looks_like_its_stdvisit/"&gt;reddit comments&lt;/a&gt; about the challenges faced by the C++
implementation. Could D, and my library, &lt;code&gt;SumType&lt;/code&gt;, in particular, do better?&lt;/p&gt;
&lt;h3&gt;Methodology&lt;/h3&gt;
&lt;p&gt;To answer these questions, I designed a simple program and implemented it in C,
in C++, and in D with both &lt;code&gt;Algebraic&lt;/code&gt; and &lt;code&gt;SumType&lt;/code&gt;, using the most natural
and idomatic code for each language and library. My goal was to find out how
well a production-grade, optimizing compiler would handle each sum type
implementation in typical use. The compilers I chose were &lt;code&gt;clang&lt;/code&gt; 8, &lt;code&gt;clang++&lt;/code&gt; 8,
and &lt;code&gt;ldc&lt;/code&gt; 1.17.0, all of which use LLVM 8 for their backends. All programs were
compiled with optimization level &lt;code&gt;-O2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Each test program does the following things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Defines 10 empty &lt;code&gt;struct&lt;/code&gt; types, named &lt;code&gt;T0&lt;/code&gt; through &lt;code&gt;T9&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Defines a sum type with 10 members, one of each of those types.&lt;/li&gt;
&lt;li&gt;Defines a function that takes an instance of that sum type as an argument,
  and returns a unique integer for each possible type the sum type can hold.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For illustration's sake, here's the C++ version, slightly abridged:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;variant&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Source: https://en.cppreference.com/w/cpp/utility/variant/visit&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nl"&gt;overloaded&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()...;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;overloaded&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;overloaded&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Ts&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;T0&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;T9&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;example_variant&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;variant&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T9&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;do_visit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;example_variant&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;visit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;overloaded&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;T0&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;T1&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;T2&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
        &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;T9&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;233&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After compiling each program, I used &lt;code&gt;objdump&lt;/code&gt; to disassemble them, and
compared the generated assembly for each version of &lt;code&gt;do_visit&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;All of the code used, along with the commands used for compilation and
disassembly, are available on Github in the repository
&lt;a href="https://github.com/pbackus/variant-comparison"&gt;pbackus/variant-comparison&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Results&lt;/h3&gt;
&lt;h4&gt;C&lt;/h4&gt;
&lt;p&gt;The C version uses a &lt;code&gt;union&lt;/code&gt; with an &lt;code&gt;enum&lt;/code&gt; tag as its sum type implementation,
and a switch statement for its "visit" function. It's the straightforward,
obvious implementation you'd use if you were writing the code by hand, without
worrying about making it generic, so it makes a good baseline to compare the
other versions to.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;00000000000000a0 &amp;lt;do_visit&amp;gt;:
  a0:    cmp    $0xa,%edi         # check if type index is in-bounds
  a3:    jae    b0
  a5:    movslq %edi,%rax
  a8:    mov    0x0(,%rax,4),%eax # get result from global array
  af:    retq   

  # Error path
  b0:    push   %rax
  b1:    mov    $0x0,%edi
  b6:    mov    $0x0,%esi
  bb:    mov    $0x0,%ecx
  c0:    mov    $0x45,%edx
  c5:    callq  ca                # __assert_fail
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you might expect, the compiler is able to optimize the entire thing down
into a single array lookup. It's so compact, in fact, that the code for calling
&lt;code&gt;libc&lt;/code&gt;'s assertion-failure function takes up more space than the actual logic.&lt;/p&gt;
&lt;h4&gt;C++&lt;/h4&gt;
&lt;p&gt;The C++ version uses &lt;code&gt;std::variant&lt;/code&gt; and &lt;code&gt;std::visit&lt;/code&gt;, with the &lt;a href="https://en.cppreference.com/w/cpp/utility/variant/visit"&gt;&lt;code&gt;overloaded&lt;/code&gt;
helper template&lt;/a&gt; from cppreference.com to allow passing a set of labmda
functions as a visitor. This is standard-library code, so we should expect it
to be as well-optimized as the best and brightest C++ developers around can
make it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0000000000000000 &amp;lt;do_visit(std::__1::example_variant)&amp;gt;:
   0:    sub    $0x18,%rsp
   4:    mov    %rdi,%rax
   7:    mov    %rdi,0x8(%rsp)
   c:    shr    $0x20,%rax
  10:    mov    $0xffffffff,%ecx
  15:    cmp    %rcx,%rax        # check if type index is in-bounds
  18:    je     38
  1a:    mov    %rsp,%rcx
  1d:    mov    %rcx,0x10(%rsp)
  22:    lea    0x10(%rsp),%rdi
  27:    lea    0x8(%rsp),%rsi
  2c:    callq  *0x0(,%rax,8)    # call function pointer in global array
  33:    add    $0x18,%rsp
  37:    retq   

  # Error path
  38:    callq  3d               # __throw_bad_variant_access
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The main thing to notice here is that, unlike in the C version, the compiler is
not able to inline the individual visitor functions. Instead, it generates an
indirect call to a function pointer stored in a global array. (The individual
lambda functions, of course, all consist of a single &lt;code&gt;mov&lt;/code&gt; followed by a
return.)&lt;/p&gt;
&lt;p&gt;I'm not enough of a C++ expert to understand the implementation of
&lt;code&gt;std::visit&lt;/code&gt;, so I can only guess why this is the case. Maybe the optimizer
just gives up after too many layers of template-metaprogramming gunk?
Regardless, it's bad news for fans of zero-cost abstractions, since there's a
clear overhead here compared to the C assembly.&lt;/p&gt;
&lt;p&gt;[UPDATE: Reddit user matthieum &lt;a href="https://www.reddit.com/r/programming/comments/ddi5wb/beating_stdvisit_without_really_trying/f2jrkrc/"&gt;suggests&lt;/a&gt; that the function pointers
themselves are likely to blame.]&lt;/p&gt;
&lt;h4&gt;D, with Algebraic&lt;/h4&gt;
&lt;p&gt;This version uses the sum type implementation from D's standard library,
Phobos. Rather than create a dedicated sum type, the Phobos developers opted to
make &lt;code&gt;Algebraic&lt;/code&gt; a thin wrapper around &lt;code&gt;Variant&lt;/code&gt;, D's equivalent of C++17's
&lt;code&gt;std::any&lt;/code&gt;. That choice turns out to have far-reaching repercussions, as we're
about to see.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0000000000000000 &amp;lt;int dalgebraic.do_visit(ExampleAlgebraic)&amp;gt;:
   0:    jmpq   5 # int std.variant.visitImpl!(true, ExampleAlgebraic, ...)

0000000000000000 &amp;lt;int std.variant.visitImpl!(true, ExampleAlgebraic, ...)
   0:    push   %rbx
   1:    sub    $0x10,%rsp
   5:    cmp    0x0(%rip),%rdi    # check for uninitialized Variant
   c:    je     217               # if so, go to error path
  12:    mov    %rdi,%rbx

  # This part is repeated 10 times, once for each type
  15:    movq   $0x0,0x8(%rsp)    # prepare arguments for VariantN.handler
  1e:    lea    0x8(%rsp),%rdi
  23:    xor    %esi,%esi
  25:    xor    %edx,%edx
  27:    callq  *%rbx             # VariantN.handler: get TypeInfo for current type
  29:    mov    0x8(%rsp),%rsi
  2e:    mov    0x0(%rip),%rdi    # get TypeInfo for T0
  35:    callq  3a                # Object.opEquals: compare TypeInfos
  3a:    mov    %eax,%ecx
  3c:    mov    $0x3,%eax         # load return value for T0 into %eax
  41:    test   %cl,%cl           # check if Object.opEquals returned true
  43:    jne    211               # if so, go to return
 ...:    ...    ...

 # After checking for T9
 20f:    je     283               # if none of the types matched, assert(false)
 211:    add    $0x10,%rsp
 215:    pop    %rbx
 216:    retq   

 # Error path
 217:    mov    0x0(%rip),%rdi    # get ClassInfo for VariantException
 21e:    callq  223               # _d_allocclass: allocate VariantException
 223:    mov    %rax,%rbx
 226:    mov    0x0(%rip),%rax    # initialize VariantException vtable
 22d:    mov    %rax,(%rbx)
 230:    movq   $0x0,0x8(%rbx)
 238:    mov    0x0(%rip),%rax    # initialize VariantException
 23f:    movups 0x50(%rax),%xmm0
 243:    movups %xmm0,0x50(%rbx)
 247:    movups 0x10(%rax),%xmm0
 24b:    movups 0x20(%rax),%xmm1
 24f:    movups 0x30(%rax),%xmm2
 253:    movups 0x40(%rax),%xmm3
 257:    movups %xmm3,0x40(%rbx)
 25b:    movups %xmm2,0x30(%rbx)
 25f:    movups %xmm1,0x20(%rbx)
 263:    movups %xmm0,0x10(%rbx)
 267:    lea    0x0(%rip),%rdx    # get message for VariantException
 26e:    mov    $0x2f,%esi
 273:    mov    %rbx,%rdi
 276:    callq  27b               # VariantException.__ctor
 27b:    mov    %rbx,%rdi
 27e:    callq  283               # _d_throw_exception
 283:    lea    0x0(%rip),%rsi    # get error message for assert
 28a:    mov    $0x4b,%edi
 28f:    mov    $0xa1c,%edx
 294:    callq  299               # call D runtime assert function
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The good part is that &lt;code&gt;ldc&lt;/code&gt; is able to inline the lambdas into the body of
&lt;code&gt;visitImpl&lt;/code&gt;. The bad part is, well, everything else.&lt;/p&gt;
&lt;p&gt;Because &lt;code&gt;Algebraic&lt;/code&gt; is implemented using &lt;code&gt;Variant&lt;/code&gt;, it has to rely on runtime
type information (&lt;code&gt;TypeInfo&lt;/code&gt;) to check the type of the current value. And
because it uses &lt;code&gt;TypeInfo&lt;/code&gt;, rather than an integer index like the C and C++
versions, these checks can't be condensed down into a single array lookup, or
even a jump table. Finally, as if that wasn't enough, each &lt;code&gt;TypeInfo&lt;/code&gt;
comparison requires a virtual method call to &lt;code&gt;Object.opEquals&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Beyond these obvious pessimizations, the other thing that stands out is the
sheer volume of the generated code. It's an order of magnitude larger than both
the C and C++ versions, with significant bloat in both the normal and error
paths. Not only is this bad in isolation, since it puts unnecessary pressure on
the instrution cache, it also means that potential optimization opportunities
exposed by inlining the C and C++ versions of &lt;code&gt;do_visit&lt;/code&gt; won't be available to
D code using &lt;code&gt;Algebraic&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;D, with SumType&lt;/h4&gt;
&lt;p&gt;This version uses my own implementation of a sum type in D. &lt;code&gt;SumType&lt;/code&gt; does not
rely at all on runtime type information, and instead uses D's powerful
compile-time reflection and metaprogramming capabilities to try to generate
code as close to the C version as possible. Let's see how well it does.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;0000000000000000 &amp;lt;int dsumtype.do_visit(ExampleSumType)&amp;gt;:
   0:    push   %rax
   1:    movsbq 0x10(%rsp),%rax    # get type index from stack
   7:    cmp    $0xa,%rax          # check if type index is in-bounds
   b:    jae    19
   d:    lea    0x0(%rip),%rcx     # load address of global array
  14:    mov    (%rcx,%rax,4),%eax # get result from global array
  17:    pop    %rcx
  18:    retq   

  # Error path
  19:    lea    0x0(%rip),%rdx     # get error message
  20:    mov    $0x4ca,%edi
  25:    mov    $0x9,%esi
  2a:    callq  2f                 # __switch_error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As it turns out, it's almost exactly the same as the C version: a single array
lookup, plus some code for error handling. In fact, as far as I can tell, the
only difference has to do with the way the function argument is passed in
registers—the C version is able to avoid spilling anything to the stack,
whereas this version has a &lt;code&gt;push&lt;/code&gt; and a &lt;code&gt;pop&lt;/code&gt; at the beginning and end,
respectively.&lt;/p&gt;
&lt;p&gt;Still, I think it's fair to say that this is a true zero-cost abstraction, and
that the claim of "zero overhead compared to hand-written C" is justified.&lt;/p&gt;
&lt;p&gt;[UPDATE: Reddit user ais52 &lt;a href="https://www.reddit.com/r/programming/comments/ddi5wb/beating_stdvisit_without_really_trying/f2oe4hu/"&gt;explains&lt;/a&gt; that the purpose of the &lt;code&gt;push&lt;/code&gt;/&lt;code&gt;pop&lt;/code&gt;
pair is to adjust the alignment of the stack pointer.]&lt;/p&gt;
&lt;h3&gt;Conclusions&lt;/h3&gt;
&lt;p&gt;If creating a zero-overhead generic sum type is so easy that even I can do it,
why doesn't C++ have one? Are the &lt;code&gt;libc++&lt;/code&gt; developers a bunch of dummies?&lt;/p&gt;
&lt;p&gt;No, of course not—but they are working with a significant handicap: C++.&lt;/p&gt;
&lt;p&gt;The source code for &lt;code&gt;variant&lt;/code&gt; is terrifyingly complex. In order to get the
results shown above, the authors have had to use every template metaprogramming
trick in the book, and then some. It's clearly the result of immense effort by
some very skilled programmers.&lt;/p&gt;
&lt;p&gt;By contrast, the source code of &lt;code&gt;SumType&lt;/code&gt; is almost embarrassingly simple. The
reason &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;SumType&lt;/code&gt;'s equivalent of &lt;code&gt;std::visit&lt;/code&gt;, is able to optimize
down to the same code as a C switch statement is that it literally is a switch
statement, with a &lt;code&gt;static foreach&lt;/code&gt; loop inside to generate the cases.&lt;/p&gt;
&lt;p&gt;To be honest, I wasn't even thinking about optimization when I coded &lt;code&gt;SumType&lt;/code&gt;.
I wanted to make sure the interface was nice, and figured I could worry about
performance later. But D makes it so easy to write simple, straightforward code
that the compiler understands, I ended up &lt;a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/"&gt;falling into the pit of success&lt;/a&gt;
and beating &lt;code&gt;std::visit&lt;/code&gt; entirely by accident.&lt;/p&gt;</content><category term="Programming"></category><category term="c++"></category><category term="dlang"></category><category term="assembly"></category></entry></feed>